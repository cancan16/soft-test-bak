
# 结构数据模型


![](../pic/2023-05-11-22-12-03.png)
关系模式使用二维表格表示

![](../pic/2023-05-11-22-13-18.png)

# 三级模式结构

![](../pic/2023-05-11-22-15-25.png)
![](../pic/2023-05-11-22-15-05.png)

---

![](../pic/2023-05-11-22-17-02.png)

# 两级映像

![](../pic/2023-05-11-22-19-43.png)

---

![](../pic/2023-05-11-22-21-20.png)

---

![](../pic/2023-05-11-22-23-39.png)

# 关系模式基本术语

![](../pic/2023-05-11-22-29-47.png)
关系模式: table(属性1，属性2
候选码: 主键ID,或联合唯一索引，能够标记一条数据
主属性: 主码中的属性

# 完整性约束

![](../pic/2023-05-11-22-42-27.png)
实体完整性: 主码的值不能为空，也不能部分为空
参照完整新: 外键一定能够在其他表中找到，或者外键为空

# 并，差，交，笛卡尔积

![](../pic/2023-05-11-22-48-23.png)

![](../pic/2023-05-12-07-56-03.png)

# 投影选择

![](../pic/2023-05-11-22-55-34.png)
投影:选择任意其中的列组合的新的关系
选择: 任意摸个字段=某个值 的数据组成新关系

![](../pic/2023-05-11-22-58-56.png)
B='5' B列等于5的元素
1='5' 第一个列属性等于5的元素
1=3 表示的是 第1列的值和第3列的值是否相等
![](../pic/2023-05-11-23-00-53.png)

# 等值连接

![](../pic/2023-05-12-07-57-09.png)

# 自然连接

![](../pic/2023-05-12-07-58-58.png)
1.笛卡尔积表
2.找到同名列，并把列值相同的找出，然后删掉后面表的该列
    R.A = S.A and R.B = S.B
3.A表每一行都和R表进行对比，存在一样则算为结果集。

![](../pic/2023-05-12-08-04-02.png)

---

![](../pic/2023-05-12-09-12-54.png)

---

![](../pic/2023-05-12-09-14-05.png)

---

![](../pic/2023-05-12-09-28-28.png)

---

![](../pic/2023-05-12-12-35-04.png)
自然连接如果没有匹配上则删除，如R.A1 and R.A2 都不匹配S表，则R的第一行删除


---

![](../pic/2023-05-12-12-38-00.png)
加单引号代表的是 第3列的属性值='销售部1'

![](../pic/2023-05-12-12-44-26.png)
先看第56个空，第四列是日期，因此选择C
又因为第55个空和第56个空时自然连接，因此一定有公共属性，公共部分只有商品号，因此投影中一定包含第一列

---

![](../pic/2023-05-12-12-47-29.png)
![](../pic/2023-05-12-12-53-56.png)
答案: BA

注意投影列的选择，没有括号则先投影在连接，如果有括号则先连接后投影

选出答案后和题目中的投影列进行比较，序号是否一致

---

# 自然连接转sql

![](../pic/2023-05-12-13-09-32.png)

R,S 表示笛卡尔积查询
自然连接，找到同名的列表，也就是条件使用并且符号进行连接

---

![](../pic/2023-05-12-13-19-06.png)

---

![](../pic/2023-05-12-13-22-57.png)

![](../pic/2023-05-12-13-28-07.png)
先筛选再笛卡尔积

---

![](../pic/2023-05-12-13-30-27.png)
这里是笛卡尔积，因此不需要排除列，所以序号为1~8

# 查询

![](../pic/2023-05-12-14-01-19.png)

---

![](../pic/2023-05-12-14-08-27.png)

---

![](../pic/2023-05-12-21-49-58.png)

---

![](../pic/2023-05-12-21-51-11.png)


# 函数依赖

![](../pic/2023-05-12-21-58-09.png)
R: 关系名
U: 属性
F: 函数依赖

![](../pic/2023-05-12-22-01-32.png)
包含关系

![](../pic/2023-05-12-22-05-38.png)
函数依赖: 某个属性由候选码中的属性决定
那么就称属性函数依赖与候选码
完全依赖: 学号和课程号共同决定成绩
部分函数依赖: 学号和课程号共同决定成绩，学号也可以单独决定成绩，那么成绩部分依赖候选码

![](../pic/2023-05-12-22-08-57.png)
多个数据性中若存在部分属性决定 Y 则成为部分依赖

![](../pic/2023-05-12-22-12-49.png)
传递依赖: X->Z X可以决定Z

![](../pic/2023-05-12-22-23-05.png)
Z包含于Y, 又 X->Y 因此 X->Z

# 属性闭包计算

![](../pic/2023-05-12-22-26-18.png)
根据生成的闭包，匹配关系并替换
求A的闭包: A可以决定B，A可以决定H => (ABH)
求ABH的闭包: A可以决定B => (ABH)
    B可以决定DH => (ABDH)
    H没有=>(ABDH)
求ABDH的闭包:
    A可以决定B B已经存在=> (ABDH)
    B可以决定DH DH已经存在 => (ABDH)
    D没有
    H没有 因此结果是(ABDH)
当这次结果和上次结果一样时就停止。
![](../pic/2023-05-12-22-49-04.png)
说明A是表的候选键，因为A闭包结果包含了所有的列
又因为只有一个属性A时候选码，因此A也是主码


候选码: 根据关系属性能推导出所有的属性

---

![](../pic/2023-05-12-23-02-05.png)
没有在右边出现过的属性，候选码一定包含该属性
如A不能被其他属性决定，因此候选码一定包含A

然后使用代入法，根据选项求闭包

主属性: 包含在候选关键字中的属性都是主属性，
AC AB 包含 A B C 因此有3个主属性 0个非主属性

---

![](../pic/2023-05-12-23-12-48.png)

---
![](../pic/2023-05-12-23-14-02.png)
所有属性就是全码

---

![](../pic/2023-05-12-23-21-09.png)

![](../pic/2023-05-12-23-22-23.png)

---

![](../pic/2023-05-12-23-31-29.png)
A->BC 可以分解为: A->B 和 A->C

![](../pic/2023-05-12-23-32-44.png)


---

![](../pic/2023-05-12-23-33-56.png)

---

![](../pic/2023-05-12-23-37-11.png)

---

![](../pic/2023-05-12-23-39-59.png)
真子集能够决定U那么其不是候选码
答案:AD

# 第一范式

![](../pic/2023-05-13-09-29-25.png)

![](../pic/2023-05-12-23-43-32.png)
候选码中包含的属性为主属性，不包含的属性为非主属性。
![](../pic/2023-05-12-23-56-21.png)

![](../pic/2023-05-13-09-30-51.png)

改成如下，就能保证满足第一范式
![](../pic/2023-05-13-09-31-21.png)


# 第二范式

![](../pic/2023-05-13-00-13-21.png)

候选码有: (学号，课程号)
完全依赖: 如  学号课程表->成绩 
不在候选码中的属性为非主属性，如姓名、学院、院长、课程名
学号可以单独决定姓名，因此姓名为部分依赖与候选码
成绩完全依赖与候选码。

# 关系模式分解

![](../pic/2023-05-13-08-22-31.png)
把非主属性分解出去，并添加决定非主属性的属性，
让主属性和非主属性构成新的关系
同理 课程号 课程
同理 学号 课程号 成绩

保证分解后的关系:
每一个非主属性都完全函数依赖于候选码，该候选码可以使主键或者联合主键

![](../pic/2023-05-13-09-14-06.png)

第一范式和第二范式存在函数传递依赖，因此仍然有冗余和操作异常。

# 第三范式

![](../pic/2023-05-13-09-21-31.png)
传递函数依赖中，如果X->Y Y->Z1,Z2,Z3
那么Y->Z1,Z2,Z3可以分解成关系
Y Z1 Z2 Z3

第三范式存在的问题:
![](../pic/2023-05-13-09-33-29.png)
找出候选码:
    (书店，图书)、(店长，图书)

第一范式: 每个属性都不能再分为子属性
第二范式: 每个关系中，属性都完全函数依赖于主属性
第三范式: 每个关系中，非主属性都不非传递函数依赖于候选码
    库存量也都是由候选码中的属性所决定的，因此不存在传递函数依赖于候选码
    存在的问题: 主属性存在对候选码的分部分函数依赖或者在主属性和候选码之间存在传递依赖


![](../pic/2023-05-13-09-48-50.png)
存在主属性对部分候选码的依赖，如书店，部分依赖于候选码(店长，图书)中的店长


为消除第三范式存在的问题: 主属性存在对候选码的分部分函数依赖或者在主属性和候选码之间存在传递依赖。
需要解决该问题，使第三范式升级为BCNF。


![](../pic/2023-05-13-10-15-56.png)
候选码: 候选码属性能决定所有的属性

主属性对候选码的部分函数依赖或传递函数依赖

总结:
![](../pic/2023-05-13-10-29-55.png)


---

判断非主属性部分函数依赖于主属性的技巧:
![](../pic/2023-05-13-10-42-49.png)
找到主属性和非主属性

![](../pic/2023-05-13-10-45-32.png)
候选码有: (时间，学生)
因此主属性有: 时间 学生
非主属性有: 课程 教师 成绩 教室
找到非主属性依赖于部分主属性
根据关系依次判断 ？-> 课程  (时间，教室) -> 课程
这里时间，教室看做整体，因此课程不部分依赖于主属性


![](../pic/2023-05-13-11-00-47.png)

(时间，学生) -> 教室
(时间，教室) -> 课程
因此有: (时间，(时间，学生)) -> 课程 即 (时间，学生) -> 课程
课程 -> 教师，所以: (时间，学生) -> 教师
因此非主属性教师对码存在传递函数依赖。
如下图:
![](../pic/2023-05-13-11-28-47.png)

![](../pic/2023-05-13-10-29-55.png)
判断是否满足第二范式:
    非主属性不部分依赖与候选码
判断是否满足第三范式:
    非属性不存在传递依赖于与候选码
判断是否满足BCNF:
    主属性不部分依赖于候选码，而且主属性不存在传递依赖于与候选码

---

![](../pic/2023-05-13-11-45-58.png)
解答:
是否满足第二范式:
判断非主属性是否不部分函数依赖于候选码
例如存在: 时间->非主属性或者学生->非主属性，则认为非主属性部分依赖于候选码。
因为教室完全依赖于候选码，因此不满足部分依赖的条件，
所以非主属性不部分依赖于候选码，符合第二范式。

是否满足第三范式:
非主属性不存在传递依赖于候选码

由于(时间,学生)->教室，（时间,教室）->课程，
因此有（时间,学生）-> 教室
所以，非属性书存在传递依赖于与候选码，则不满足第三范式

第56空

找出主属性:
R的关系有 (学生,课程)->成绩
(学生,课程)

判断是否满足BCNF范式:
主属性不部分依赖于候选码也不存在传递依赖于候选码

---

![](../pic/2023-05-13-11-50-06.png)
A

---

![](../pic/2023-05-13-11-51-47.png)

---

![](../pic/2023-05-13-11-56-48.png)



---

![](../pic/2023-05-13-12-08-13.png)

# 关系分解

---

![](../pic/2023-05-13-12-14-29.png)
唯一索引或者联合索引为 候选码

![](../pic/2023-05-13-12-17-05.png)
存在传递函数依赖
![](../pic/2023-05-13-12-17-59.png)

---

![](../pic/2023-05-13-12-29-47.png)
需要把部分函数依赖分解出去
零件名称和供应商所在地，为部分函数依赖，需要单独拥有关系。

---

![](../pic/2023-05-13-13-14-26.png)

---

# 保持函数依赖

判断是否有损连接:
相互自然连接后的属性是否缺少，如果有缺少则有损

判断是否保持函数依赖:
题目中存在的关系能在分解后的关系中找得到

![](../pic/2023-05-13-13-22-54.png)
选项关系中，都能找到给定的关系 
分解后，所存在的关系是否都能在题目中表现
如 A选项中无法找到C->D的关系

---

![](../pic/2023-05-13-13-24-44.png)
无损连接: 分解关系中自然连接后，都能找到属性


![](../pic/2023-05-13-13-29-45.png)
函数依赖: A1A3->A3
分解后都不存在函数依赖

---

![](../pic/2023-05-13-13-35-50.png)
无损连接: 关系之间一定有交集


# 需求分析阶段

![](../pic/2023-05-13-13-48-34.png)

---

![](../pic/2023-05-13-15-29-10.png)


---

![](../pic/2023-05-13-15-32-07.png)

# 概念结构设计

![](../pic/2023-05-13-15-42-13.png)


---

![](../pic/2023-05-13-16-01-07.png)

---

![](../pic/2023-05-13-16-13-24.png)

---

![](../pic/2023-05-13-16-13-52.png)

---

![](../pic/2023-05-13-16-30-20.png)

---
![](../pic/2023-05-13-16-35-43.png)


---

![](../pic/2023-05-13-16-38-14.png)

---

![](../pic/2023-05-13-16-40-03.png)


---

![](../pic/2023-05-13-16-42-04.png)

52:C

---

![](../pic/2023-05-13-16-43-32.png)

# 事务管理

![](../pic/2023-05-13-16-45-39.png)

---

![](../pic/2023-05-13-16-52-16.png)

---

![](../pic/2023-05-13-16-54-53.png)

---

![](../pic/2023-05-13-16-58-17.png)
事务对数据加排它锁，则其他事务不能再加任何锁
事务对数据加共享锁，则其他事务只能再加共享锁

![](../pic/2023-05-13-17-00-16.png)

---

![](../pic/2023-05-13-17-02-45.png)

---

![](../pic/2023-05-13-17-04-46.png)

---

![](../pic/2023-05-13-17-05-27.png)

---

![](../pic/2023-05-13-17-05-55.png)


![](../pic/2023-05-13-17-07-00.png)

---

![](../pic/2023-05-13-17-07-44.png)

---

![](../pic/2023-05-13-17-09-34.png)

---

![](../pic/2023-05-13-17-10-42.png)


---

![](../pic/2023-05-13-17-12-19.png)

---

![](../pic/2023-05-13-17-13-30.png)

---

![](../pic/2023-05-13-17-13-54.png)

---

![](../pic/2023-05-13-17-15-16.png)